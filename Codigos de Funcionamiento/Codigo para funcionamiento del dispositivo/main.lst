CCS PCM C Compiler, Version 5.115, 29001               31-Oct-24 08:31

               Filename:   C:\Users\vepro\OneDrive\Documentos\Residencia\Simulacion\Codigo\main.lst

               ROM used:   748 words (9%)
                           Largest free fragment is 2048
               RAM used:   17 (5%) at main() level
                           34 (9%) worst case
               Stack used: 6 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   1DD
0003:  NOP
.................... #include <16F877A.h>  // Archivo de configuración del PIC16F877A
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  28
0009:  RETLW  0C
000A:  RETLW  01
000B:  RETLW  06
000C:  DATA 49,37
000D:  DATA E9,31
000E:  DATA E9,30
000F:  DATA 6E,32
0010:  DATA 6F,17
0011:  DATA 2E,17
0012:  DATA 00,00
0013:  DATA C2,34
0014:  DATA 65,37
0015:  DATA F6,32
0016:  DATA EE,34
0017:  DATA E4,37
0018:  DATA 21,00
0019:  DATA D3,34
001A:  DATA 73,3A
001B:  DATA E5,36
001C:  DATA 61,10
001D:  DATA CC,34
001E:  DATA 73,3A
001F:  DATA 6F,00
0020:  DATA D0,37
0021:  DATA F4,32
0022:  DATA EE,31
0023:  DATA E9,30
0024:  DATA 20,27
0025:  DATA 69,3B
0026:  DATA 65,36
0027:  DATA A0,18
0028:  DATA 00,01
0029:  DATA D0,37
002A:  DATA F4,32
002B:  DATA EE,31
002C:  DATA E9,30
002D:  DATA 20,27
002E:  DATA 69,3B
002F:  DATA 65,36
0030:  DATA 20,19
0031:  DATA 00,01
0032:  DATA D0,37
0033:  DATA F4,32
0034:  DATA EE,31
0035:  DATA E9,30
0036:  DATA 20,27
0037:  DATA 69,3B
0038:  DATA 65,36
0039:  DATA A0,19
003A:  DATA 00,01
003B:  DATA 45,3A
003C:  DATA 61,38
003D:  DATA 61,10
003E:  DATA 56,17
003F:  DATA A0,3C
0040:  DATA 20,29
0041:  DATA 2E,1D
0042:  DATA 00,00
*
0187:  MOVF   0B,W
0188:  MOVWF  2B
0189:  BCF    0B.7
018A:  BSF    03.5
018B:  BSF    03.6
018C:  BSF    0C.7
018D:  BSF    0C.0
018E:  NOP
018F:  NOP
0190:  BCF    03.5
0191:  BCF    03.6
0192:  BTFSC  2B.7
0193:  BSF    0B.7
0194:  BSF    03.6
0195:  MOVF   0C,W
0196:  ANDLW  7F
0197:  BTFSC  03.2
0198:  GOTO   1DB
0199:  BCF    03.6
019A:  MOVWF  2B
019B:  BSF    03.6
019C:  MOVF   0D,W
019D:  BCF    03.6
019E:  MOVWF  2C
019F:  BSF    03.6
01A0:  MOVF   0F,W
01A1:  BCF    03.6
01A2:  MOVWF  2D
01A3:  MOVF   2B,W
01A4:  MOVWF  2E
01A5:  CALL   162
01A6:  MOVF   2C,W
01A7:  BSF    03.6
01A8:  MOVWF  0D
01A9:  BCF    03.6
01AA:  MOVF   2D,W
01AB:  BSF    03.6
01AC:  MOVWF  0F
01AD:  BCF    03.6
01AE:  MOVF   0B,W
01AF:  MOVWF  2E
01B0:  BCF    0B.7
01B1:  BSF    03.5
01B2:  BSF    03.6
01B3:  BSF    0C.7
01B4:  BSF    0C.0
01B5:  NOP
01B6:  NOP
01B7:  BCF    03.5
01B8:  BCF    03.6
01B9:  BTFSC  2E.7
01BA:  BSF    0B.7
01BB:  BSF    03.6
01BC:  RLF    0C,W
01BD:  RLF    0E,W
01BE:  ANDLW  7F
01BF:  BTFSC  03.2
01C0:  GOTO   1DB
01C1:  BCF    03.6
01C2:  MOVWF  2B
01C3:  BSF    03.6
01C4:  MOVF   0D,W
01C5:  BCF    03.6
01C6:  MOVWF  2C
01C7:  BSF    03.6
01C8:  MOVF   0F,W
01C9:  BCF    03.6
01CA:  MOVWF  2D
01CB:  MOVF   2B,W
01CC:  MOVWF  2E
01CD:  CALL   162
01CE:  MOVF   2C,W
01CF:  BSF    03.6
01D0:  MOVWF  0D
01D1:  BCF    03.6
01D2:  MOVF   2D,W
01D3:  BSF    03.6
01D4:  MOVWF  0F
01D5:  INCF   0D,F
01D6:  BTFSC  03.2
01D7:  INCF   0F,F
01D8:  BCF    03.6
01D9:  GOTO   187
01DA:  BSF    03.6
01DB:  BCF    03.6
01DC:  RETURN
.................... 
.................... #list
.................... 
.................... #fuses HS, NOWDT, NOPROTECT, BROWNOUT, PUT, NOLVP  // Configuración de fusibles
.................... #use delay(clock=20000000)  // Configuración de frecuencia de reloj a 20 MHz
*
0043:  MOVLW  2F
0044:  MOVWF  04
0045:  BCF    03.7
0046:  MOVF   00,W
0047:  BTFSC  03.2
0048:  GOTO   056
0049:  MOVLW  06
004A:  MOVWF  78
004B:  CLRF   77
004C:  DECFSZ 77,F
004D:  GOTO   04C
004E:  DECFSZ 78,F
004F:  GOTO   04B
0050:  MOVLW  7B
0051:  MOVWF  77
0052:  DECFSZ 77,F
0053:  GOTO   052
0054:  DECFSZ 00,F
0055:  GOTO   049
0056:  RETURN
.................... 
.................... 
.................... #use I2C(master, sda=PIN_C4, scl=PIN_C3, fast=400000)  // Configuración I2C para el LCD
0057:  BCF    14.7
0058:  BCF    0C.3
0059:  MOVF   3C,W
005A:  MOVWF  13
005B:  MOVLW  02
005C:  BTFSC  14.7
005D:  GOTO   065
005E:  BSF    03.5
005F:  BTFSC  14.2
0060:  GOTO   05F
0061:  MOVLW  00
0062:  BTFSC  11.6
0063:  MOVLW  01
0064:  BCF    03.5
0065:  MOVWF  78
0066:  RETURN
.................... #include "i2c_Flex_LCD.c"  // Librería para control del LCD I2C
.................... //----------------------------------------------------------------------------- 
.................... // Title:         i2c_Flex_LCD 
.................... // Description:   Driver for common LCD with 1/2/3 or 4 rows by 1...20 columns 
.................... //                using PCF8574T interface board with I2C protocol. 
.................... // Date:          Nov-2013 
.................... // Ver.Rev.:      1.1 
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 
.................... //                "20X4_LCD_I2C_DRIVER.h" from Pumrin S. and "lcd4_i2c.c" from XP8100 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // lcd_init() Must be called before any other function. 
.................... // 
.................... // lcd_putc(c) Will display c on the next position of the LCD. 
.................... //  
.................... //     \f Clear LCD display 
.................... //     \n Set write position on next lcd line 
.................... //     \b LCD backspace 
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1) 
.................... // 
.................... // lcd_backlight_led(ON)/lcd_backlight_led(OFF) = Turn ON/OFF LCD Backlight LED 
.................... // 
.................... //----------------------------------------------------------------------------- 
.................... // LCD pins D0-D3 are not used. 
.................... //----------------------------------------------------------------------------- 
.................... // 
.................... // Comment   : Control of a compatible LCD (1...4 rows by 1...4 columns) from 
.................... //              a bus I2C with an EXPANDER of I/O with connection I2C. 
.................... //              The tests of these routines have been programmed using the IC 
.................... //              Phillips PCF8574T. I've used 4 bits mode programming. 
.................... //              The 8 bits mode programming is possible if you use 2 x PCF8574T. 
.................... //              RW Pin is not being used. 
.................... // 
.................... // As defined in the following structure the pin connection is as follows: 
.................... // 
.................... //  PCF8574P     LCD 
.................... //  ========     ====== 
.................... //     P0        RS 
.................... //     P1        RW    (Not used!) 
.................... //     P2        Enable  
.................... //     P3        Led Backlight 
.................... //     P4        D4 
.................... //     P5        D5 
.................... //     P6        D6 
.................... //     P7        D7 
.................... // 
.................... //  The SCL and SDA pins should be pull-up resistor as shown below: 
.................... // 
.................... //             +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SDA pin  
.................... //(SDA)                      
.................... //              +5v 
.................... //               | 
.................... //               < 
.................... //               > 4.7K        
.................... //               <          
.................... //To PIC         |          To i2c slave 
.................... //pin xx ------------------ SCL pin  
.................... //(SCL) 
.................... // 
.................... //To PIC                    To i2c slave 
.................... //Vss pin ----------------- Vss or ground pin  
.................... //                | 
.................... //              ----- 
.................... //               ---  Ground 
.................... //                -  
.................... //  
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS" 
.................... //----------------------------------------------------------------------------- 
.................... byte LCD_ADDR ;//             0x4E        //I2C slave address for LCD module 
.................... byte lcd_total_rows ;//       2           //Number of rows: 1,2,3 or 4 
.................... byte lcd_total_columns ;//    16          //Number of columns: 1...20   
.................... 
.................... #define RS                    0b00000001  //P0 - PCF8574T Pin connected to RS 
.................... #define RW                    0b00000010  //P1 - PCF8574T Pin connected to RW 
.................... #define ENABLE                0b00000100  //P2 - PCF8574T Pin connected to EN 
.................... #define LCD_BACKLIGHT         0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED 
.................... 
.................... #define addr_row_one          0x00        //LCD RAM address for row 1 
.................... #define addr_row_two          0x40        //LCD RAM address for row 2 
.................... #define addr_row_three        0x14        //LCD RAM address for row 3 
.................... #define addr_row_four         0x54        //LCD RAM address for row 4 
.................... 
.................... #define ON                    1 
.................... #define OFF                   0 
.................... #define NOT                   ~ 
.................... #define data_shifted          data<<4 
.................... int8 new_row_request=1, BACKLIGHT_LED=LCD_BACKLIGHT; 
.................... 
.................... void lcd_backlight_led(byte bl) 
.................... {  
....................       If (bl) BACKLIGHT_LED=LCD_BACKLIGHT; else BACKLIGHT_LED=OFF; 
.................... } 
.................... 
.................... void i2c_send_nibble(byte data, byte type) 
.................... {    
....................    switch (type) 
0067:  MOVF   3A,W
0068:  XORLW  00
0069:  BTFSC  03.2
006A:  GOTO   06F
006B:  XORLW  01
006C:  BTFSC  03.2
006D:  GOTO   092
006E:  GOTO   0B6
....................    {      
....................       case 0 :      
....................       i2c_write(data_shifted | BACKLIGHT_LED); 
006F:  SWAPF  39,W
0070:  MOVWF  77
0071:  MOVLW  F0
0072:  ANDWF  77,F
0073:  MOVF   77,W
0074:  IORWF  25,W
0075:  MOVWF  3B
0076:  MOVWF  3C
0077:  CALL   057
....................       delay_cycles(1); 
0078:  NOP
....................       i2c_write(data_shifted | ENABLE | BACKLIGHT_LED ); 
0079:  SWAPF  39,W
007A:  MOVWF  77
007B:  MOVLW  F0
007C:  ANDWF  77,F
007D:  MOVF   77,W
007E:  IORLW  04
007F:  IORWF  25,W
0080:  MOVWF  3B
0081:  MOVWF  3C
0082:  CALL   057
....................       delay_us(2); 
0083:  MOVLW  03
0084:  MOVWF  77
0085:  DECFSZ 77,F
0086:  GOTO   085
....................       i2c_write(data_shifted & NOT ENABLE | BACKLIGHT_LED); 
0087:  SWAPF  39,W
0088:  MOVWF  77
0089:  MOVLW  F0
008A:  ANDWF  77,F
008B:  MOVF   77,W
008C:  ANDLW  FB
008D:  IORWF  25,W
008E:  MOVWF  3B
008F:  MOVWF  3C
0090:  CALL   057
....................       break; 
0091:  GOTO   0B6
....................       
....................       case 1 : 
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED); 
0092:  SWAPF  39,W
0093:  MOVWF  77
0094:  MOVLW  F0
0095:  ANDWF  77,F
0096:  MOVF   77,W
0097:  IORLW  01
0098:  IORWF  25,W
0099:  MOVWF  3B
009A:  MOVWF  3C
009B:  CALL   057
....................       delay_cycles(1); 
009C:  NOP
....................       i2c_write(data_shifted | RS | ENABLE | BACKLIGHT_LED ); 
009D:  SWAPF  39,W
009E:  MOVWF  77
009F:  MOVLW  F0
00A0:  ANDWF  77,F
00A1:  MOVF   77,W
00A2:  IORLW  01
00A3:  IORLW  04
00A4:  IORWF  25,W
00A5:  MOVWF  3B
00A6:  MOVWF  3C
00A7:  CALL   057
....................       delay_us(2); 
00A8:  MOVLW  03
00A9:  MOVWF  77
00AA:  DECFSZ 77,F
00AB:  GOTO   0AA
....................       i2c_write(data_shifted | RS | BACKLIGHT_LED); 
00AC:  SWAPF  39,W
00AD:  MOVWF  77
00AE:  MOVLW  F0
00AF:  ANDWF  77,F
00B0:  MOVF   77,W
00B1:  IORLW  01
00B2:  IORWF  25,W
00B3:  MOVWF  3B
00B4:  MOVWF  3C
00B5:  CALL   057
....................       break; 
....................    } 
00B6:  RETURN
.................... } 
....................     
.................... void lcd_send_byte(byte data, byte type) 
....................    { 
....................         i2c_start(); 
00B7:  BSF    03.5
00B8:  BSF    11.0
00B9:  BTFSC  11.0
00BA:  GOTO   0B9
....................         i2c_write(LCD_ADDR); 
00BB:  BCF    03.5
00BC:  MOVF   21,W
00BD:  MOVWF  3C
00BE:  CALL   057
....................         i2c_send_nibble(data >> 4 , type); 
00BF:  SWAPF  36,W
00C0:  MOVWF  38
00C1:  MOVLW  0F
00C2:  ANDWF  38,F
00C3:  MOVF   38,W
00C4:  MOVWF  39
00C5:  MOVF   37,W
00C6:  MOVWF  3A
00C7:  CALL   067
....................         i2c_send_nibble(data & 0xf , type); 
00C8:  MOVF   36,W
00C9:  ANDLW  0F
00CA:  MOVWF  38
00CB:  MOVWF  39
00CC:  MOVF   37,W
00CD:  MOVWF  3A
00CE:  CALL   067
....................         i2c_stop();        
00CF:  BSF    03.5
00D0:  BSF    11.2
00D1:  BTFSC  11.2
00D2:  GOTO   0D1
00D3:  BCF    03.5
00D4:  RETURN
....................    } 
.................... 
.................... void lcd_clear() 
.................... {  
....................         lcd_send_byte(0x01,0); 
00D5:  MOVLW  01
00D6:  MOVWF  36
00D7:  CLRF   37
00D8:  CALL   0B7
....................         delay_ms(2); 
00D9:  MOVLW  02
00DA:  MOVWF  2F
00DB:  CALL   043
....................         new_row_request=1; 
00DC:  MOVLW  01
00DD:  MOVWF  24
00DE:  RETURN
.................... } 
.................... 
.................... void lcd_init(byte ADDR, byte col, byte row) 
.................... { 
....................    byte i;
....................    byte CONST lcd_type=2;  // 0=5x7, 1=5x10, 2=2 lines 
....................    byte CONST LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; // These bytes need to be sent to the LCD to start it up.
....................    
....................    LCD_ADDR =ADDR;//             0x4E        //I2C slave address for LCD module 
00DF:  MOVF   2B,W
00E0:  MOVWF  21
....................    lcd_total_rows =row;//       2           //Number of rows: 1,2,3 or 4 
00E1:  MOVF   2D,W
00E2:  MOVWF  22
....................    lcd_total_columns= col ;
00E3:  MOVF   2C,W
00E4:  MOVWF  23
....................    disable_interrupts(GLOBAL); 
00E5:  BCF    0B.6
00E6:  BCF    0B.7
00E7:  BTFSC  0B.7
00E8:  GOTO   0E6
....................    delay_ms(50); //LCD power up delay 
00E9:  MOVLW  32
00EA:  MOVWF  2F
00EB:  CALL   043
....................     
....................    i2c_start(); 
00EC:  BSF    03.5
00ED:  BSF    11.0
00EE:  BTFSC  11.0
00EF:  GOTO   0EE
....................    i2c_write(LCD_ADDR); 
00F0:  BCF    03.5
00F1:  MOVF   21,W
00F2:  MOVWF  3C
00F3:  CALL   057
....................       i2c_send_nibble(0x00,0); 
00F4:  CLRF   39
00F5:  CLRF   3A
00F6:  CALL   067
....................       delay_ms(15); 
00F7:  MOVLW  0F
00F8:  MOVWF  2F
00F9:  CALL   043
....................     
....................    for (i=1;i<=3;++i)    
00FA:  MOVLW  01
00FB:  MOVWF  2E
00FC:  MOVF   2E,W
00FD:  SUBLW  03
00FE:  BTFSS  03.0
00FF:  GOTO   109
....................    { 
....................       i2c_send_nibble(0x03,0); 
0100:  MOVLW  03
0101:  MOVWF  39
0102:  CLRF   3A
0103:  CALL   067
....................       delay_ms(5); 
0104:  MOVLW  05
0105:  MOVWF  2F
0106:  CALL   043
0107:  INCF   2E,F
0108:  GOTO   0FC
....................    }    
....................       i2c_send_nibble(0x02,0); 
0109:  MOVLW  02
010A:  MOVWF  39
010B:  CLRF   3A
010C:  CALL   067
....................       delay_ms(5); 
010D:  MOVLW  05
010E:  MOVWF  2F
010F:  CALL   043
....................    i2c_stop(); 
0110:  BSF    03.5
0111:  BSF    11.2
0112:  BTFSC  11.2
0113:  GOTO   112
....................     
....................    for (i=0;i<=3;++i) { 
0114:  BCF    03.5
0115:  CLRF   2E
0116:  MOVF   2E,W
0117:  SUBLW  03
0118:  BTFSS  03.0
0119:  GOTO   125
....................    lcd_send_byte(LCD_INIT_STRING[i],0); 
011A:  MOVF   2E,W
011B:  CALL   004
011C:  MOVWF  2F
011D:  MOVWF  36
011E:  CLRF   37
011F:  CALL   0B7
....................    delay_ms(5); 
0120:  MOVLW  05
0121:  MOVWF  2F
0122:  CALL   043
0123:  INCF   2E,F
0124:  GOTO   116
....................    } 
....................    lcd_clear();  //Clear Display 
0125:  CALL   0D5
....................    enable_interrupts(GLOBAL); 
0126:  MOVLW  C0
0127:  IORWF  0B,F
0128:  BCF    0A.3
0129:  BCF    0A.4
012A:  GOTO   21C (RETURN)
.................... } 
.................... 
.................... void lcd_gotoxy( byte x, byte y) 
.................... { 
.................... byte row,column,row_addr,lcd_address; 
.................... static char data; 
*
0202:  BCF    03.5
0203:  CLRF   26
.................... 
....................    if (y>lcd_total_rows) row=lcd_total_rows; else row=y; 
*
012B:  MOVF   30,W
012C:  SUBWF  22,W
012D:  BTFSC  03.0
012E:  GOTO   132
012F:  MOVF   22,W
0130:  MOVWF  31
0131:  GOTO   134
0132:  MOVF   30,W
0133:  MOVWF  31
....................   
....................    switch(row) 
0134:  MOVF   31,W
0135:  XORLW  01
0136:  BTFSC  03.2
0137:  GOTO   142
0138:  XORLW  03
0139:  BTFSC  03.2
013A:  GOTO   144
013B:  XORLW  01
013C:  BTFSC  03.2
013D:  GOTO   147
013E:  XORLW  07
013F:  BTFSC  03.2
0140:  GOTO   14A
0141:  GOTO   14D
....................    { 
....................       case 1:  row_addr=addr_row_one;     break; 
0142:  CLRF   33
0143:  GOTO   14E
....................       case 2:  row_addr=addr_row_two;     break; 
0144:  MOVLW  40
0145:  MOVWF  33
0146:  GOTO   14E
....................       case 3:  row_addr=addr_row_three;   break; 
0147:  MOVLW  14
0148:  MOVWF  33
0149:  GOTO   14E
....................       case 4:  row_addr=addr_row_four;    break; 
014A:  MOVLW  54
014B:  MOVWF  33
014C:  GOTO   14E
....................       default: row_addr=addr_row_one;     break;  
014D:  CLRF   33
....................    }  
....................     
....................    if (x>lcd_total_columns) column=lcd_total_columns; else column=x;  
014E:  MOVF   2F,W
014F:  SUBWF  23,W
0150:  BTFSC  03.0
0151:  GOTO   155
0152:  MOVF   23,W
0153:  MOVWF  32
0154:  GOTO   157
0155:  MOVF   2F,W
0156:  MOVWF  32
....................    lcd_address=(row_addr+(column-1)); 
0157:  MOVLW  01
0158:  SUBWF  32,W
0159:  ADDWF  33,W
015A:  MOVWF  34
....................    lcd_send_byte(0x80|lcd_address,0); 
015B:  MOVF   34,W
015C:  IORLW  80
015D:  MOVWF  35
015E:  MOVWF  36
015F:  CLRF   37
0160:  CALL   0B7
0161:  RETURN
.................... } 
.................... 
.................... //Display the character on LCD screen. 
.................... void LCD_PUTC(char in_data) 
.................... {    
....................   switch(in_data) 
0162:  MOVF   2E,W
0163:  XORLW  0C
0164:  BTFSC  03.2
0165:  GOTO   16D
0166:  XORLW  06
0167:  BTFSC  03.2
0168:  GOTO   16F
0169:  XORLW  02
016A:  BTFSC  03.2
016B:  GOTO   17C
016C:  GOTO   181
....................    {  
....................      case '\f': lcd_clear();                       break;                
016D:  CALL   0D5
016E:  GOTO   186
....................       
....................      case '\n': 
....................      new_row_request++; 
016F:  INCF   24,F
....................      if (new_row_request>lcd_total_rows) new_row_request=1; 
0170:  MOVF   24,W
0171:  SUBWF  22,W
0172:  BTFSC  03.0
0173:  GOTO   176
0174:  MOVLW  01
0175:  MOVWF  24
....................      lcd_gotoxy(1, new_row_request); 
0176:  MOVLW  01
0177:  MOVWF  2F
0178:  MOVF   24,W
0179:  MOVWF  30
017A:  CALL   12B
....................      break; 
017B:  GOTO   186
....................                   
....................      case '\b': lcd_send_byte(0x10,0);             break; 
017C:  MOVLW  10
017D:  MOVWF  36
017E:  CLRF   37
017F:  CALL   0B7
0180:  GOTO   186
....................         
....................      default: lcd_send_byte(in_data,1);            break;      
0181:  MOVF   2E,W
0182:  MOVWF  36
0183:  MOVLW  01
0184:  MOVWF  37
0185:  CALL   0B7
....................       
....................    } 
0186:  RETURN
.................... } 
.................... 
.................... 
.................... #define TIEMPO_ENCENDIDO 5000  // Duración de encendido de cada etapa de vibración
.................... 
.................... void main() {
*
01DD:  MOVF   03,W
01DE:  ANDLW  1F
01DF:  MOVWF  03
01E0:  MOVLW  FF
01E1:  MOVWF  20
01E2:  BSF    20.3
01E3:  MOVF   20,W
01E4:  BSF    03.5
01E5:  MOVWF  07
01E6:  BCF    03.5
01E7:  BSF    20.4
01E8:  MOVF   20,W
01E9:  BSF    03.5
01EA:  MOVWF  07
01EB:  MOVLW  0C
01EC:  MOVWF  13
01ED:  MOVLW  28
01EE:  BCF    03.5
01EF:  MOVWF  14
01F0:  BSF    03.5
01F1:  BCF    14.7
01F2:  BCF    14.6
01F3:  MOVLW  01
01F4:  BCF    03.5
01F5:  MOVWF  24
01F6:  MOVLW  08
01F7:  MOVWF  25
01F8:  CLRF   28
01F9:  CLRF   27
01FA:  BSF    03.5
01FB:  BSF    1F.0
01FC:  BSF    1F.1
01FD:  BSF    1F.2
01FE:  BCF    1F.3
01FF:  MOVLW  07
0200:  MOVWF  1C
0201:  BCF    03.7
....................     setup_ccp1(CCP_PWM);  // Configurar CCP1 en modo PWM
*
0204:  BCF    20.2
0205:  MOVF   20,W
0206:  BSF    03.5
0207:  MOVWF  07
0208:  BCF    03.5
0209:  BCF    07.2
020A:  MOVLW  0C
020B:  MOVWF  17
....................     setup_timer_2(T2_DIV_BY_16, 255, 1);
020C:  MOVLW  00
020D:  MOVWF  78
020E:  IORLW  06
020F:  MOVWF  12
0210:  MOVLW  FF
0211:  BSF    03.5
0212:  MOVWF  12
....................     set_pwm1_duty(0);  // Apagar PWM al inicio
0213:  BCF    03.5
0214:  CLRF   15
....................     lcd_init(0x4E, 16, 2);  // Inicializar el LCD en la dirección I2C 0x4E
0215:  MOVLW  4E
0216:  MOVWF  2B
0217:  MOVLW  10
0218:  MOVWF  2C
0219:  MOVLW  02
021A:  MOVWF  2D
021B:  GOTO   0DF
.................... 
....................     // Mensaje de arranque en el LCD
....................     lcd_gotoxy(1, 1);
021C:  MOVLW  01
021D:  MOVWF  2F
021E:  MOVWF  30
021F:  CALL   12B
....................     LCD_PUTC("Iniciando...");  // Mensaje breve de inicio
0220:  MOVLW  0C
0221:  BSF    03.6
0222:  MOVWF  0D
0223:  MOVLW  00
0224:  MOVWF  0F
0225:  BCF    03.6
0226:  CALL   187
.................... 
....................     delay_ms(1000);  // Retardo reducido para cargar
0227:  MOVLW  04
0228:  MOVWF  2B
0229:  MOVLW  FA
022A:  MOVWF  2F
022B:  CALL   043
022C:  DECFSZ 2B,F
022D:  GOTO   229
....................     
....................     lcd_clear();
022E:  CALL   0D5
....................     delay_ms(200);  // Esperar un momento antes de continuar
022F:  MOVLW  C8
0230:  MOVWF  2F
0231:  CALL   043
.................... 
....................     // Mensaje de bienvenida en el LCD
....................     lcd_gotoxy(1, 1);
0232:  MOVLW  01
0233:  MOVWF  2F
0234:  MOVWF  30
0235:  CALL   12B
....................     LCD_PUTC("Bienvenido!");
0236:  MOVLW  13
0237:  BSF    03.6
0238:  MOVWF  0D
0239:  MOVLW  00
023A:  MOVWF  0F
023B:  BCF    03.6
023C:  CALL   187
....................     lcd_gotoxy(1, 2);
023D:  MOVLW  01
023E:  MOVWF  2F
023F:  MOVLW  02
0240:  MOVWF  30
0241:  CALL   12B
....................     LCD_PUTC("Sistema Listo");
0242:  MOVLW  19
0243:  BSF    03.6
0244:  MOVWF  0D
0245:  MOVLW  00
0246:  MOVWF  0F
0247:  BCF    03.6
0248:  CALL   187
....................     delay_ms(1000);  // Mantener el mensaje visible por 1 segundo
0249:  MOVLW  04
024A:  MOVWF  2B
024B:  MOVLW  FA
024C:  MOVWF  2F
024D:  CALL   043
024E:  DECFSZ 2B,F
024F:  GOTO   24B
....................     lcd_clear();  // Limpiar el LCD
0250:  CALL   0D5
....................     
....................     while(TRUE) {
....................         int duty = 0;  // Ciclo de trabajo inicial del motor apagado
0251:  CLRF   29
.................... 
....................         // Selección de nivel de potencia con PWM en función de los pines de entrada
....................         if(input(PIN_B0)) {  // Nivel de potencia 1 (26% de PWM)
0252:  BSF    03.5
0253:  BSF    06.0
0254:  BCF    03.5
0255:  BTFSS  06.0
0256:  GOTO   265
....................             duty = (int)(0.26 * 1023);
0257:  MOVLW  09
0258:  MOVWF  29
....................             lcd_gotoxy(1, 1);
0259:  MOVLW  01
025A:  MOVWF  2F
025B:  MOVWF  30
025C:  CALL   12B
....................             lcd_putc("Potencia Nivel 1");  // Mostrar nivel de vibración 1
025D:  MOVLW  20
025E:  BSF    03.6
025F:  MOVWF  0D
0260:  MOVLW  00
0261:  MOVWF  0F
0262:  BCF    03.6
0263:  CALL   187
....................         } 
0264:  GOTO   28A
....................         else if(input(PIN_B1)) {  // Nivel de potencia 2 (52% de PWM)
0265:  BSF    03.5
0266:  BSF    06.1
0267:  BCF    03.5
0268:  BTFSS  06.1
0269:  GOTO   278
....................             duty = (int)(0.52 * 1023);
026A:  MOVLW  13
026B:  MOVWF  29
....................             lcd_gotoxy(1, 1);
026C:  MOVLW  01
026D:  MOVWF  2F
026E:  MOVWF  30
026F:  CALL   12B
....................             lcd_putc("Potencia Nivel 2");  // Mostrar nivel de vibración 2
0270:  MOVLW  29
0271:  BSF    03.6
0272:  MOVWF  0D
0273:  MOVLW  00
0274:  MOVWF  0F
0275:  BCF    03.6
0276:  CALL   187
....................         } 
0277:  GOTO   28A
....................         else if(input(PIN_B2)) {  // Nivel de potencia 3 (80% de PWM)
0278:  BSF    03.5
0279:  BSF    06.2
027A:  BCF    03.5
027B:  BTFSS  06.2
027C:  GOTO   28A
....................             duty = (int)(0.80 * 1023);
027D:  MOVLW  32
027E:  MOVWF  29
....................             lcd_gotoxy(1, 1);
027F:  MOVLW  01
0280:  MOVWF  2F
0281:  MOVWF  30
0282:  CALL   12B
....................             lcd_putc("Potencia Nivel 3");  // Mostrar nivel de vibración 3
0283:  MOVLW  32
0284:  BSF    03.6
0285:  MOVWF  0D
0286:  MOVLW  00
0287:  MOVWF  0F
0288:  BCF    03.6
0289:  CALL   187
....................         }
.................... 
....................         // Si el botón de acción (PIN_B3) se presiona, iniciar el motor con el nivel de potencia seleccionado
....................         while((input(PIN_B0) && input(PIN_B3)) || (input(PIN_B1) && input(PIN_B3)) || (input(PIN_B2) && input(PIN_B3))) {
028A:  BSF    03.5
028B:  BSF    06.0
028C:  BCF    03.5
028D:  BTFSS  06.0
028E:  GOTO   294
028F:  BSF    03.5
0290:  BSF    06.3
0291:  BCF    03.5
0292:  BTFSC  06.3
0293:  GOTO   2A8
0294:  BSF    03.5
0295:  BSF    06.1
0296:  BCF    03.5
0297:  BTFSS  06.1
0298:  GOTO   29E
0299:  BSF    03.5
029A:  BSF    06.3
029B:  BCF    03.5
029C:  BTFSC  06.3
029D:  GOTO   2A8
029E:  BSF    03.5
029F:  BSF    06.2
02A0:  BCF    03.5
02A1:  BTFSS  06.2
02A2:  GOTO   2E9
02A3:  BSF    03.5
02A4:  BSF    06.3
02A5:  BCF    03.5
02A6:  BTFSS  06.3
02A7:  GOTO   2E9
....................             for(int i = 0; i < 3; i++) {  // Repetir tres veces para las etapas de vibración
02A8:  CLRF   2A
02A9:  MOVF   2A,W
02AA:  SUBLW  02
02AB:  BTFSS  03.0
02AC:  GOTO   2E6
....................                 lcd_clear();  // Limpiar el LCD al inicio de cada etapa
02AD:  CALL   0D5
....................                 lcd_gotoxy(1, 1);
02AE:  MOVLW  01
02AF:  MOVWF  2F
02B0:  MOVWF  30
02B1:  CALL   12B
.................... 
....................                 // Mostrar la etapa actual en el LCD
....................                 LCD_PUTC("Etapa V. y R.:");
02B2:  MOVLW  3B
02B3:  BSF    03.6
02B4:  MOVWF  0D
02B5:  MOVLW  00
02B6:  MOVWF  0F
02B7:  BCF    03.6
02B8:  CALL   187
....................                 lcd_gotoxy(1, 2);
02B9:  MOVLW  01
02BA:  MOVWF  2F
02BB:  MOVLW  02
02BC:  MOVWF  30
02BD:  CALL   12B
....................                 lcd_putc((i + 1) + '0');  // Mostrar el número de la etapa (1, 2, o 3)
02BE:  MOVLW  01
02BF:  ADDWF  2A,W
02C0:  ADDLW  30
02C1:  MOVWF  2B
02C2:  MOVWF  2E
02C3:  CALL   162
....................                 
....................                 set_pwm1_duty(duty);
02C4:  MOVF   29,W
02C5:  MOVWF  15
....................                 delay_ms(1500);  // Reducir el retardo para disminuir la carga en Proteus
02C6:  MOVLW  06
02C7:  MOVWF  2B
02C8:  MOVLW  FA
02C9:  MOVWF  2F
02CA:  CALL   043
02CB:  DECFSZ 2B,F
02CC:  GOTO   2C8
....................                 
....................                 set_pwm1_duty(0);
02CD:  CLRF   15
....................                 delay_ms(500);  // Reducir pausa para evitar sobrecarga
02CE:  MOVLW  02
02CF:  MOVWF  2B
02D0:  MOVLW  FA
02D1:  MOVWF  2F
02D2:  CALL   043
02D3:  DECFSZ 2B,F
02D4:  GOTO   2D0
....................                 
....................                 // Activar el ESPCAM en cada etapa
....................                 output_high(PIN_D1);  // Activar ESPCAM para captura de imágenes
02D5:  BSF    03.5
02D6:  BCF    08.1
02D7:  BCF    03.5
02D8:  BSF    08.1
....................                 delay_ms(2000);  // Reducir tiempo de activación de ESPCAM
02D9:  MOVLW  08
02DA:  MOVWF  2B
02DB:  MOVLW  FA
02DC:  MOVWF  2F
02DD:  CALL   043
02DE:  DECFSZ 2B,F
02DF:  GOTO   2DB
....................                 output_low(PIN_D1);  // Apagar ESPCAM
02E0:  BSF    03.5
02E1:  BCF    08.1
02E2:  BCF    03.5
02E3:  BCF    08.1
02E4:  INCF   2A,F
02E5:  GOTO   2A9
....................             }
....................             lcd_clear();  // Limpiar el LCD después de completar las tres etapas
02E6:  CALL   0D5
....................             break;
02E7:  GOTO   2E9
02E8:  GOTO   28A
....................          }
....................            set_pwm1_duty(0);  // Si no se presiona el botón B3, el motor permanece apagado
02E9:  CLRF   15
02EA:  GOTO   251
....................         }
....................     }
.................... 
02EB:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
